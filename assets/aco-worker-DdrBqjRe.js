(function(){"use strict";function w(e,n){return e.map(t=>{const o=Object.keys(t.pheromoneTo).reduce((r,i)=>(r[i]=n,r),{});return{...t,pheromoneTo:o}})}function D(e,n,t,o,r,i,s,l,h){let f=[],u=[],a=d(e),g=0,m=0;if(n==="max-min-as"){const[b,c]=$(e);g=E(s,c),m=C(g,e.length),a=w(a,g)}const re=T(e);let W=[],y=99999999999;for(let b=0;b<l;b++){let c=[];for(let k=0;k<o;k++){let ie=R(d(a),r,i);c.push(ie)}u.push(c);let[U,N]=G(c,re);switch(N<y&&(W=[...U],y=N),n){case"as":a=J(d(e),c,s,o);break;case"elitist":a=Z(e,W,y,t),a=J(d(e),c,s,o);break;case"max-min-as":a=ee(d(e),U,N,c,o,s,m,g),g=E(s,N),m=C(g,e.length);break}f.push(d(a)),b%25===0&&h(100*b/l)}return[f,u]}function E(e,n){return 1/(e*n)}function C(e,n){return e*(1-Math.pow(.05,1/n))/((n/2-1)*Math.pow(.05,1/n))}function $(e){const n=v(e),t=[n.name];let o=0,r=n;for(P(e,r.name);j(e);){const s=_(e,r);if(s==null)throw new Error(`Closest Neighbor of ${r.name} doesn't Exist!!`);t.push(s.name),o+=r.distanceTo[s.name],r=s,P(e,r.name)}const i=p(e,t[t.length-1]);if(i==null)throw new Error("Last visited city doesn't Exist!!");return o+=i.distanceTo[t[0]],[t,o]}function j(e){return e.some(n=>n.isVisited===!1)}function _(e,n){const t=L(e,n);let o=9999999,r="";for(let i of t)n.distanceTo[i]<o&&(r=i,o=n.distanceTo[i]);return p(e,r)}function R(e,n,t){let o=[],r=v(e);for(P(e,r.name),o.push(r.name);o.length<e.length;){let i=q(e,r,n,t);if(i===null)break;if(i===void 0)throw new Error("Error: Something wrong happened when getting the nextCity!");P(e,i.name),o.push(i.name),r=i}return o}function v(e){return e[Q(0,e.length-1)]}function G(e,n){let t=[],o=999999;for(const r of e){const i=O(r,n);i<=o&&(t=[...r],o=i)}return[t,o]}function P(e,n){for(let t of e)if(t.name===n){t.isVisited=!0;break}}function q(e,n,t,o){const r=L(e,n);if(r.length==0)return null;if(r.length==1)return p(e,r[0]);let i=[];const s=K(n,r,t,o);for(const f of r){let u=H(n,r,f,s,t,o);i.push(u)}let l=0,h=Math.random();for(let f=0;f<i.length;f++){if(isNaN(i[f]))throw new Error("Error while calculating the probabilities of moving to the next city!");if(l+=i[f],h<l)return p(e,r[f])}throw new Error(`We went through all the cities but randomNumber=${h} is bigger than cumulative prob=${l}, probabilityOfMovingtoNeighbors=${i}`)}function L(e,n){return B(n).filter(o=>{let r=p(e,o);if(r!=null)return r.isVisited==!1;console.error(`City ${o} not Found in the array cities!`)})}function B(e){let n=[];for(let t in e.distanceTo)n.push(t);return n}function p(e,n){return e.find(t=>t.name===n)}function H(e,n,t,o,r,i){return n.length===0?0:n.length===1?1:(e.pheromoneTo[t]===0&&(e.pheromoneTo[t]+=1e-6),e.pheromoneTo[t]**r*(1/e.distanceTo[t])**i/o)}function K(e,n,t,o){let r=0;for(let i of n)e.pheromoneTo[i]===0&&(e.pheromoneTo[i]+=1e-6),r+=e.pheromoneTo[i]**t*(1/e.distanceTo[i])**o;return r}function S(e){const n=e.toFixed(3);return parseFloat(n)}function Q(e,n){const t=Math.ceil(e),o=Math.floor(n);return Math.floor(Math.random()*(o-t+1)+t)}function d(e){let n=[];for(const t of e){let o={x:t.x,y:t.y,name:t.name,isVisited:t.isVisited,distanceTo:JSON.parse(JSON.stringify(t.distanceTo)),pheromoneTo:JSON.parse(JSON.stringify(t.pheromoneTo)),lineWidthTo:JSON.parse(JSON.stringify(t.lineWidthTo)),edgeAntFlow:JSON.parse(JSON.stringify(t.edgeAntFlow))};n.push(o)}return n}function I(e,n,t,o=.01,r=4){const i=(r-o)/e;let s=0;return t in n&&(s=i*n[t]),s<.01?.01:s>4?4:S(s)}function T(e){const n={};for(let t of e)for(let o in t.distanceTo)n[t.name+o]=t.distanceTo[o];return n}function O(e,n){let t=0;for(let o=0;o<e.length-1;o++){let r=e[o]+e[o+1];r in n?t+=n[r]:console.error(`Edge-${r} doesn't exist in the object allEdgesLengths!`)}return S(t+n[e[0]+e[e.length-1]])}function X(e,n){const t=T(e),o={};for(const r of n){const i=Y(r,t);for(let s=0;s<r.length-1;s++){const l=r[s]+r[s+1],h=r[s+1]+r[s];l in o?(o[l]+=i,o[h]+=i):(o[l]=i,o[h]=i)}}return o}function Y(e,n){return 1/O(e,n)}function J(e,n,t,o){const r=X(e,n),i=M(n);for(const s of e){for(let l in s.pheromoneTo){const h=s.name+l,f=s.pheromoneTo[l],u=z(f,r,h,t);s.pheromoneTo[l]=u,s.lineWidthTo[l]=I(o,i,h)}s.edgeAntFlow=JSON.parse(JSON.stringify(x(s,i)))}return e.forEach(s=>s.isVisited=!1),e}function Z(e,n,t,o){const r=A(n),i=o*(1/t);for(const s of e)for(const l in s.pheromoneTo){const h=s.name+l;r.has(h)&&(s.pheromoneTo[l]+=i)}return e}function A(e){const n=new Set;for(let t=0;t<e.length-1;t++)n.add(e[t]+e[t+1]);return n.add(e[e.length-1]+e[0]),n}function M(e){const n={};for(const t of e){for(let i=0;i<t.length-1;i++){const s=t[i]+t[i+1],l=t[i+1]+t[i];s in n&&l in n?(n[s]+=1,n[l]+=1):(n[s]=1,n[l]=1)}const o=t[t.length-1]+t[0],r=t[0]+t[t.length-1];o in n&&r in n?(n[o]+=1,n[r]+=1):(n[o]=1,n[r]=1)}return n}function x(e,n){const t=B(e);let o={};for(const r of t){const i=e.name+r,s=r+e.name;i in n?o[r]=n[i]:s in n?o[r]=n[s]:o[r]=0}return o}function z(e,n,t,o){let r=0;return t in n&&(r=n[t]),(1-o)*e+r}function ee(e,n,t,o,r,i,s,l){const h=A(n),f=1/t,u=M(o);for(const a of e){for(const g in a.pheromoneTo){const m=a.name+g;h.has(m)&&(a.pheromoneTo[g]=V(a.pheromoneTo[g],f,s,l,i,!0)),a.pheromoneTo[g]=V(a.pheromoneTo[g],f,s,l,i,!1),a.lineWidthTo[g]=I(r,u,m)}a.edgeAntFlow=JSON.parse(JSON.stringify(x(a,u)))}return e.forEach(a=>a.isVisited=!1),e}function V(e,n,t,o,r,i){const s=i?(1-r)*e+n:(1-r)*e;return s<t?t:s>o?o:s}function te(e,n){let t=[];const o=T(e);let r=[],i=999999999;for(let s of n){const[l,h]=F(s,o);h<i&&(r=[...l],i=h),t.push(r)}return t}function ne(e,n){let t=[];const o=T(e);for(const r of n){const[i,s]=F(r,o);t.push(i)}return t}function F(e,n){let t=[],o=999999999;for(const r of e){const i=O(r,n);i<o&&(t=[...r],o=i)}return[t,o]}function oe(e){if(e==null)return[];let n=[];for(let t=0;t<e.length;t++){const o=e[t];let r={x:o.x,y:o.y,name:o.name,isVisited:o.isVisited,distanceTo:JSON.parse(JSON.stringify(o.distanceTo)),pheromoneTo:JSON.parse(JSON.stringify(o.pheromoneTo)),lineWidthTo:JSON.parse(JSON.stringify(o.lineWidthTo)),edgeAntFlow:JSON.parse(JSON.stringify(o.edgeAntFlow))};n.push(r)}return n}self.onmessage=function(e){const{cities:n,userControls:t}=e.data;let o=oe(n);t.acoMode!=="max-min-as"&&(o=w(n,Number(t.initialPheromone)));const[r,i]=D(o,t.acoMode,Number(t.elitistWeight),Number(t.colonySize),Number(t.alpha),Number(t.beta),Number(t.rho),Number(t.nbrOfIterations),h=>{self.postMessage({type:"progress",value:h})});let s=te(o,i),l=ne(o,i);self.postMessage({type:"result",updatedCities:o,ACOIterations:r,antsChosenPaths:i,localBestPathPerIteration:l,globalBestPathPerIteration:s})}})();
